def first(a, b, c = '默认参数'):
    print('a  通过位置参数赋值 %s' % a)
    print('c  默认参数  %s' % c)
    print(' b 通过关键字参数 %s ' % b)
# first(3, b = 'sssssssss', c= 'aaaa')

#函数定义时默认参数(缺省参数)一定要在定义是放到形参元组的最后面，
#默认参数后面出现非默认参数是会报错
#默认参数和非默认参数都可以通过位置参数和关键字参数进行值传递
#函数调用传参时位置参数在前，关键字参数在后，关键字参数后面出现以位置参数形式
#传参时会报错
#实参为元组时，需在前面加*。实参为字典时，需在前面加**。
#有不定长参数和默认参数时，定义函数时，默认参数放在*args(即所有位置参数之后)之后。
#有**kwargs时，在定义时其必须放在最后面


def first1(*args, **kwargs):
    '函数的文档说明'
    print(' *args   %s    %s ' % (args, type(args)))
    print(' *kwargs   %s    %s ' % (kwargs, type(kwargs)))
# first1('fsfs', 'fsdfdsf', 'fdsfsdfsda')
# help(first1)

#不定长参数传递，定义函数时形参的个数不能确定时，可定义为不定长参数
#*args该形参用于接收函数调用时通过位置参数传递过来的所有实参，通过元组的结构存储。
#**args形参用于接收函数调用时通过关键字参数传递过来的所有实参，通过字典的形式存储。
#当实参中没有通过某种方式(位置参数，关键字参数)传递参数时，其相应的数据结构为空。
#函数调用时，所有的位置参数在前，关键字参数在后


#拆包 ： 列表元组字典都可以直接进行拆包，但变量和元素个数必须相等，否则程序异常


my_lsit = [1, 2, 3, 4]
def my_print(list):
    print(list)
    # list = list + [9]  #不会对my_list造成影响
    list += [9]          #会改变my_list
    print(list)
# 当向函数中传入可变参数时，函数内部执行的+=操作会对传入的参数进行修改
#  += 操作符可原地对可变变量进行修改。 = 会重新创建一个新的变量，因为一般等号右边的表达式创建了一个新的变量
# print(my_lsit)
# my_print(my_lsit)
# print(my_lsit)

list1 = [1, 3, 4, 6, 7]


def list1(b, a = '999'):
    print(a)
    print(id(b))
    print(id(a))
    # a.append(b)
    print('测试')
    a= a + 'xxx'
    print(a)
    print(id(a))
#函数调用时引用传递，不是值传递。类似于c中的函数指针传参


#当使用可变类型的数据作为函数的默认参数时，多次调用函数的过程中，该默认参数的id不变
#多次调用函数的作用会累加在该可变对象上（即多次调用操作同一处内存
#函数中默认参数的id在多次调用函数时相同，多次函数调用使用同一处内存。所以默认参数不能
# 使用可变类型的变量，否则多次函数调用的结果会残留在该内存处。
# 使用不可变类型的变量作为默认参数时，由于其不可变，即使对变量进行赋值也不会残留（赋值时已经指向了别的内存地址）。


def my_add(a, b):
    """
    :param a: 数字1
    :param b: 数字2
    :return: 两个数字之和
    """
    return a + b

help(my_add)

a1 = 1
def a11():
    global a1
    print(a1)
    a1 = 342323


    print(a1)


a11()
print(a1)